;(function (undefined) {
/**
 * Require the given path.
 *
 * @param {String} path
 * @return {Object} exports
 * @api public
 */

function require(path, parent, orig) {
  var resolved = require.resolve(path);

  // lookup failed
  if (null == resolved) {
    orig = orig || path;
    parent = parent || 'root';
    var err = new Error('Failed to require "' + orig + '" from "' + parent + '"');
    err.path = orig;
    err.parent = parent;
    err.require = true;
    throw err;
  }

  var module = require.modules[resolved];

  // perform real require()
  // by invoking the module's
  // registered function
  if (!module.exports) {
    module.exports = {};
    module.client = module.component = true;
    module.call(this, module.exports, require.relative(resolved), module);
  }

  return module.exports;
}

/**
 * Registered modules.
 */

require.modules = {};

/**
 * Registered aliases.
 */

require.aliases = {};

/**
 * Resolve `path`.
 *
 * Lookup:
 *
 *   - PATH/index.js
 *   - PATH.js
 *   - PATH
 *
 * @param {String} path
 * @return {String} path or null
 * @api private
 */

require.resolve = function(path) {
  if (path.charAt(0) === '/') path = path.slice(1);

  var paths = [
    path,
    path + '.js',
    path + '.json',
    path + '/index.js',
    path + '/index.json'
  ];

  for (var i = 0; i < paths.length; i++) {
    var path = paths[i];
    if (require.modules.hasOwnProperty(path)) return path;
    if (require.aliases.hasOwnProperty(path)) return require.aliases[path];
  }
};

/**
 * Normalize `path` relative to the current path.
 *
 * @param {String} curr
 * @param {String} path
 * @return {String}
 * @api private
 */

require.normalize = function(curr, path) {
  var segs = [];

  if ('.' != path.charAt(0)) return path;

  curr = curr.split('/');
  path = path.split('/');

  for (var i = 0; i < path.length; ++i) {
    if ('..' == path[i]) {
      curr.pop();
    } else if ('.' != path[i] && '' != path[i]) {
      segs.push(path[i]);
    }
  }

  return curr.concat(segs).join('/');
};

/**
 * Register module at `path` with callback `definition`.
 *
 * @param {String} path
 * @param {Function} definition
 * @api private
 */

require.register = function(path, definition) {
  require.modules[path] = definition;
};

/**
 * Alias a module definition.
 *
 * @param {String} from
 * @param {String} to
 * @api private
 */

require.alias = function(from, to) {
  if (!require.modules.hasOwnProperty(from)) {
    throw new Error('Failed to alias "' + from + '", it does not exist');
  }
  require.aliases[to] = from;
};

/**
 * Return a require function relative to the `parent` path.
 *
 * @param {String} parent
 * @return {Function}
 * @api private
 */

require.relative = function(parent) {
  var p = require.normalize(parent, '..');

  /**
   * lastIndexOf helper.
   */

  function lastIndexOf(arr, obj) {
    var i = arr.length;
    while (i--) {
      if (arr[i] === obj) return i;
    }
    return -1;
  }

  /**
   * The relative require() itself.
   */

  function localRequire(path) {
    var resolved = localRequire.resolve(path);
    return require(resolved, parent, path);
  }

  /**
   * Resolve relative to the parent.
   */

  localRequire.resolve = function(path) {
    var c = path.charAt(0);
    if ('/' == c) return path.slice(1);
    if ('.' == c) return require.normalize(p, path);

    // resolve deps by returning
    // the dep in the nearest "deps"
    // directory
    var segs = parent.split('/');
    var i = lastIndexOf(segs, 'deps') + 1;
    if (!i) i = 0;
    path = segs.slice(0, i + 1).join('/') + '/deps/' + path;
    return path;
  };

  /**
   * Check if module is defined at `path`.
   */

  localRequire.exists = function(path) {
    return require.modules.hasOwnProperty(localRequire.resolve(path));
  };

  return localRequire;
};
require.register("component-indexof/index.js", Function("exports, require, module",
"\nvar indexOf = [].indexOf;\n\nmodule.exports = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};//@ sourceURL=component-indexof/index.js"
));
require.register("component-emitter/index.js", Function("exports, require, module",
"\n/**\n * Module dependencies.\n */\n\nvar index = require('indexof');\n\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks[event] = this._callbacks[event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  var self = this;\n  this._callbacks = this._callbacks || {};\n\n  function on() {\n    self.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  fn._off = on;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks[event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks[event];\n    return this;\n  }\n\n  // remove specific handler\n  var i = index(callbacks, fn._off || fn);\n  if (~i) callbacks.splice(i, 1);\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks[event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks[event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n//@ sourceURL=component-emitter/index.js"
));
require.register("seed/src/main.js", Function("exports, require, module",
"var config      = require('./config'),\n    ViewModel   = require('./viewmodel'),\n    directives  = require('./directives'),\n    filters     = require('./filters'),\n    textParser  = require('./text-parser'),\n    utils       = require('./utils')\n\nvar eventbus    = utils.eventbus,\n    api         = {}\n\n/*\n *  expose utils\n */\napi.utils = utils\n\n/*\n *  broadcast event\n */\napi.broadcast = function () {\n    eventbus.emit.apply(eventbus, arguments)\n}\n\n/*\n *  Allows user to create a custom directive\n */\napi.directive = function (name, fn) {\n    if (!fn) return directives[name]\n    directives[name] = fn\n}\n\n/*\n *  Allows user to create a custom filter\n */\napi.filter = function (name, fn) {\n    if (!fn) return filters[name]\n    filters[name] = fn\n}\n\n/*\n *  Set config options\n */\napi.config = function (opts) {\n    if (opts) {\n        for (var key in opts) {\n            config[key] = opts[key]\n        }\n    }\n    textParser.buildRegex()\n}\n\n/*\n *  Expose the main ViewModel class\n *  and add extend method\n */\napi.ViewModel = ViewModel\n\nViewModel.extend = function (options) {\n    var ExtendedVM = function (opts) {\n        opts = opts || {}\n        if (options.template) {\n            opts.template = utils.getTemplate(options.template)\n        }\n        if (options.init) {\n            opts.init = options.init\n        }\n        ViewModel.call(this, opts)\n    }\n    var p = ExtendedVM.prototype = Object.create(ViewModel.prototype)\n    p.constructor = ExtendedVM\n    if (options.props) {\n        for (var prop in options.props) {\n            p[prop] = options.props[prop]\n        }\n    }\n    if (options.id) {\n        utils.registerVM(options.id, ExtendedVM)\n    }\n    return ExtendedVM\n}\n\nmodule.exports = api//@ sourceURL=seed/src/main.js"
));
require.register("seed/src/config.js", Function("exports, require, module",
"module.exports = {\n\n    prefix      : 'sd',\n    debug       : false,\n\n    interpolateTags : {\n        open  : '{{',\n        close : '}}'\n    }\n}//@ sourceURL=seed/src/config.js"
));
require.register("seed/src/utils.js", Function("exports, require, module",
"var config        = require('./config'),\n    toString      = Object.prototype.toString,\n    templates     = {},\n    VMs           = {}\n\n/*\n *  get accurate type of an object\n */\nfunction typeOf (obj) {\n    return toString.call(obj).slice(8, -1)\n}\n\nmodule.exports = {\n\n    typeOf: typeOf,\n\n    getTemplate: function (id) {\n        var el = templates[id]\n        if (!el && el !== null) {\n            var selector = '[' + config.prefix + '-template=\"' + id + '\"]'\n            el = templates[id] = document.querySelector(selector)\n            if (el) el.parentNode.removeChild(el)\n        }\n        return el\n    },\n\n    registerVM: function (id, VM) {\n        VMs[id] = VM\n    },\n\n    getVM: function (id) {\n        return VMs[id]\n    },\n\n    log: function () {\n        if (config.debug) console.log.apply(console, arguments)\n        return this\n    },\n    \n    warn: function() {\n        if (config.debug) console.warn.apply(console, arguments)\n        return this\n    }\n}//@ sourceURL=seed/src/utils.js"
));
require.register("seed/src/compiler.js", Function("exports, require, module",
"var Emitter         = require('emitter'),\n    observe         = require('./observe'),\n    config          = require('./config'),\n    utils           = require('./utils'),\n    Binding         = require('./binding'),\n    DirectiveParser = require('./directive-parser'),\n    TextParser      = require('./text-parser'),\n    DepsParser      = require('./deps-parser')\n\nvar slice           = Array.prototype.slice\n\n// late bindings\nvar vmAttr, eachAttr\n\n/*\n *  The DOM compiler\n *  scans a DOM node and compile bindings for a ViewModel\n */\nfunction Compiler (vm, options) {\n\n    utils.log('\\nnew Compiler instance: ', vm.$el, '\\n')\n\n    // need to refresh this everytime we compile\n    eachAttr = config.prefix + '-each'\n    vmAttr   = config.prefix + '-viewmodel'\n\n    // copy options\n    options = options || {}\n    for (var op in options) {\n        this[op] = options[op]\n    }\n\n    this.vm              = vm\n    vm.$compiler         = this\n    this.el              = vm.$el\n    this.bindings        = {}\n    this.observer        = new Emitter()\n    this.directives      = []\n    this.watchers        = {}\n    // list of computed properties that need to parse dependencies for\n    this.computed        = []\n    // list of bindings that has dynamic context dependencies\n    this.contextBindings = []\n\n    // setup observer\n    this.setupObserver()\n\n    // copy data if any\n    var key, data = options.data\n    if (data) {\n        if (data instanceof vm.constructor) {\n            data = utils.dump(data)\n        }\n        for (key in data) {\n            vm[key] = data[key]\n        }\n    }\n\n    // call user init\n    if (options.init) {\n        options.init.apply(vm, options.args || [])\n    }\n\n    // now parse the DOM\n    this.compileNode(this.el, true)\n\n    // for anything in viewmodel but not binded in DOM, create bindings for them\n    for (key in vm) {\n        if (vm.hasOwnProperty(key) &&\n            key.charAt(0) !== '$' &&\n            !this.bindings[key])\n        {\n            this.createBinding(key)\n        }\n    }\n\n    // extract dependencies for computed properties\n    if (this.computed.length) DepsParser.parse(this.computed)\n    this.computed = null\n    \n    // extract dependencies for computed properties with dynamic context\n    if (this.contextBindings.length) this.bindContexts(this.contextBindings)\n    this.contextBindings = null\n    \n    utils.log('\\ncompilation done.\\n')\n}\n\n// for better compression\nvar CompilerProto = Compiler.prototype\n\n/*\n *  setup observer\n */\nCompilerProto.setupObserver = function () {\n    var bindings = this.bindings, compiler = this\n    this.observer\n        .on('get', function (key) {\n            if (DepsParser.observer.isObserving) {\n                DepsParser.observer.emit('get', bindings[key])\n            }\n        })\n        .on('set', function (key, val) {\n            console.log('set:', key, '=>', val)\n            if (!bindings[key]) compiler.createBinding(key)\n            bindings[key].update(val)\n        })\n        .on('mutate', function (key) {\n            bindings[key].refresh()\n        })\n}\n\n/*\n *  Compile a DOM node (recursive)\n */\nCompilerProto.compileNode = function (node, root) {\n\n    var compiler = this, i, j\n\n    if (node.nodeType === 3) { // text node\n\n        compiler.compileTextNode(node)\n\n    } else if (node.nodeType === 1) {\n\n        var eachExp = node.getAttribute(eachAttr),\n            vmExp   = node.getAttribute(vmAttr),\n            directive\n\n        if (eachExp) { // each block\n\n            directive = DirectiveParser.parse(eachAttr, eachExp)\n            if (directive) {\n                directive.el = node\n                compiler.bindDirective(directive)\n            }\n\n        } else if (vmExp && !root) { // nested ViewModels\n\n            var ChildVM = utils.getVM(vmExp)\n            if (ChildVM) {\n                new ChildVM({\n                    el: node,\n                    child: true,\n                    parentCompiler: compiler\n                })\n            }\n\n        } else { // normal node\n\n            // parse if has attributes\n            if (node.attributes && node.attributes.length) {\n                var attrs = slice.call(node.attributes),\n                    attr, valid, exps, exp\n                i = attrs.length\n                while (i--) {\n                    attr = attrs[i]\n                    if (attr.name === vmAttr) continue\n                    valid = false\n                    exps = attr.value.split(',')\n                    j = exps.length\n                    while (j--) {\n                        exp = exps[j]\n                        directive = DirectiveParser.parse(attr.name, exp)\n                        if (directive) {\n                            valid = true\n                            directive.el = node\n                            compiler.bindDirective(directive)\n                        }\n                    }\n                    if (valid) node.removeAttribute(attr.name)\n                }\n            }\n\n            // recursively compile childNodes\n            if (node.childNodes.length) {\n                var nodes = slice.call(node.childNodes)\n                for (i = 0, j = nodes.length; i < j; i++) {\n                    this.compileNode(nodes[i])\n                }\n            }\n        }\n    }\n}\n\n/*\n *  Compile a text node\n */\nCompilerProto.compileTextNode = function (node) {\n    var tokens = TextParser.parse(node)\n    if (!tokens) return\n    var compiler = this,\n        dirname = config.prefix + '-text',\n        el, token, directive\n    for (var i = 0, l = tokens.length; i < l; i++) {\n        token = tokens[i]\n        el = document.createTextNode('')\n        if (token.key) {\n            directive = DirectiveParser.parse(dirname, token.key)\n            if (directive) {\n                directive.el = el\n                compiler.bindDirective(directive)\n            }\n        } else {\n            el.nodeValue = token\n        }\n        node.parentNode.insertBefore(el, node)\n    }\n    node.parentNode.removeChild(node)\n}\n\n/*\n *  Create binding and attach getter/setter for a key to the viewmodel object\n */\nCompilerProto.createBinding = function (key) {\n    utils.log('  created binding: ' + key)\n\n    var binding = new Binding(this, key)\n    this.bindings[key] = binding\n\n    var baseKey = key.split('.')[0]\n    if (binding.root) {\n        // this is a root level binding. we need to define getter/setters for it.\n        this.define(baseKey, binding)\n    } else if (!this.bindings[baseKey]) {\n        // this is a nested value binding, but the binding for its root\n        // has not been created yet. We better create that one too.\n        this.createBinding(baseKey)\n    }\n\n    return binding\n}\n\n/*\n *  Defines the getter/setter for a top-level binding on the VM\n *  and observe the initial value\n */\nCompilerProto.define = function (key, binding) {\n\n    utils.log('    defined root binding: ' + key)\n\n    var compiler = this,\n        value = binding.value = this.vm[key] // save the value before redefinening it\n\n    if (utils.typeOf(value) === 'Object' && value.get) {\n        binding.isComputed = true\n        binding.rawGet = value.get\n        value.get = value.get.bind(this.vm)\n        this.computed.push(binding)\n    } else {\n        observe(value, key, compiler.observer) // start observing right now\n    }\n\n    Object.defineProperty(this.vm, key, {\n        enumerable: true,\n        get: function () {\n            compiler.observer.emit('get', key)\n            return binding.isComputed\n                ? binding.value.get({\n                    el: compiler.el,\n                    vm: compiler.vm\n                })\n                : binding.value\n        },\n        set: function (value) {\n            if (binding.isComputed) {\n                if (binding.value.set) {\n                    binding.value.set(value)\n                }\n            } else if (value !== binding.value) {\n                compiler.observer.emit('set', key, value)\n                observe(value, key, compiler.observer)\n            }\n        }\n    })\n\n}\n\n/*\n *  Add a directive instance to the correct binding & viewmodel\n */\nCompilerProto.bindDirective = function (directive) {\n\n    this.directives.push(directive)\n    directive.compiler = this\n    directive.vm       = this.vm\n\n    var key = directive.key,\n        compiler = this\n\n    // deal with each block\n    if (this.each) {\n        if (key.indexOf(this.eachPrefix) === 0) {\n            key = directive.key = key.replace(this.eachPrefix, '')\n        } else {\n            compiler = this.parentCompiler\n        }\n    }\n\n    // deal with nesting\n    compiler = traceOwnerCompiler(directive, compiler)\n    var binding = compiler.bindings[key] || compiler.createBinding(key)\n\n    binding.instances.push(directive)\n    directive.binding = binding\n\n    // for newly inserted sub-VMs (each items), need to bind deps\n    // because they didn't get processed when the parent compiler\n    // was binding dependencies.\n    var i, dep\n    if (binding.contextDeps) {\n        i = binding.contextDeps.length\n        while (i--) {\n            dep = this.bindings[binding.contextDeps[i]]\n            dep.subs.push(directive)\n        }\n    }\n\n    // invoke bind hook if exists\n    if (directive.bind) {\n        directive.bind(binding.value)\n    }\n\n    // set initial value\n    directive.update(binding.value)\n    if (binding.isComputed) {\n        directive.refresh()\n    }\n}\n\n/*\n *  Process subscriptions for computed properties that has\n *  dynamic context dependencies\n */\nCompilerProto.bindContexts = function (bindings) {\n    var i = bindings.length, j, k, binding, depKey, dep, ins\n    while (i--) {\n        binding = bindings[i]\n        j = binding.contextDeps.length\n        while (j--) {\n            depKey = binding.contextDeps[j]\n            k = binding.instances.length\n            while (k--) {\n                ins = binding.instances[k]\n                dep = ins.compiler.bindings[depKey]\n                dep.subs.push(ins)\n            }\n        }\n    }\n}\n\n/*\n *  Unbind and remove element\n */\nCompilerProto.destroy = function () {\n    utils.log('compiler destroyed: ', this.vm.$el)\n    var i, key, dir, inss\n    // remove all directives that are instances of external bindings\n    i = this.directives.length\n    while (i--) {\n        dir = this.directives[i]\n        if (dir.binding.compiler !== this) {\n            inss = dir.binding.instances\n            if (inss) inss.splice(inss.indexOf(dir), 1)\n        }\n        dir.unbind()\n    }\n    // unbind all bindings\n    for (key in this.bindings) {\n        this.bindings[key].unbind()\n    }\n    // remove el\n    this.el.parentNode.removeChild(this.el)\n}\n\n// Helpers --------------------------------------------------------------------\n\n/*\n *  determine which viewmodel a key belongs to based on nesting symbols\n */\nfunction traceOwnerCompiler (key, compiler) {\n    if (key.nesting) {\n        var levels = key.nesting\n        while (compiler.parentCompiler && levels--) {\n            compiler = compiler.parentCompiler\n        }\n    } else if (key.root) {\n        while (compiler.parentCompiler) {\n            compiler = compiler.parentCompiler\n        }\n    }\n    return compiler\n}\n\nmodule.exports = Compiler//@ sourceURL=seed/src/compiler.js"
));
require.register("seed/src/viewmodel.js", Function("exports, require, module",
"var utils    = require('./utils'),\n    Compiler = require('./compiler')\n\n/*\n *  ViewModel exposed to the user that holds data,\n *  computed properties, event handlers\n *  and a few reserved methods\n */\nfunction ViewModel (options) {\n\n    // determine el\n    this.$el = options.template\n        ? options.template.cloneNode(true)\n        : typeof options.el === 'string'\n            ? document.querySelector(options.el)\n            : options.el\n\n    // possible info inherited as an each item\n    this.$index  = options.index\n    this.$parent = options.parentCompiler && options.parentCompiler.vm\n\n    // compile. options are passed directly to compiler\n    new Compiler(this, options)\n}\n\nvar VMProto = ViewModel.prototype\n\n/*\n *  watch a key on the viewmodel for changes\n *  fire callback with new value\n */\nVMProto.$watch = function (key, callback) {\n    var self = this\n    // yield and wait for compiler to finish compiling\n    setTimeout(function () {\n        var binding = self.$compiler.bindings[key],\n            i       = binding.deps.length,\n            watcher = self.$compiler.watchers[key] = {\n                refresh: function () {\n                    callback(self[key])\n                },\n                deps: binding.deps\n            }\n        while (i--) {\n            binding.deps[i].subs.push(watcher)\n        }\n    }, 0)\n}\n\n/*\n *  remove watcher\n */\nVMProto.$unwatch = function (key) {\n    var self = this\n    setTimeout(function () {\n        var watcher = self.$compiler.watchers[key]\n        if (!watcher) return\n        var i = watcher.deps.length, subs\n        while (i--) {\n            subs = watcher.deps[i].subs\n            subs.splice(subs.indexOf(watcher))\n        }\n        self.$compiler.watchers[key] = null\n    }, 0)\n}\n\n/*\n *  unbind everything, remove everything\n */\nVMProto.$destroy = function () {\n    this.$compiler.destroy()\n    this.$compiler = null\n}\n\nmodule.exports = ViewModel//@ sourceURL=seed/src/viewmodel.js"
));
require.register("seed/src/binding.js", Function("exports, require, module",
"/*\n *  Binding class.\n *\n *  each property on the viewmodel has one corresponding Binding object\n *  which has multiple directive instances on the DOM\n *  and multiple computed property dependents\n */\nfunction Binding (compiler, key) {\n    this.value = undefined\n    this.root = key.indexOf('.') === -1\n    this.compiler = compiler\n    this.key = key\n    this.instances = []\n    this.subs = []\n    this.deps = []\n}\n\nvar BindingProto = Binding.prototype\n\n/*\n *  Process the value, then trigger updates on all dependents\n */\nBindingProto.update = function (value) {\n    this.value = value\n    var i = this.instances.length\n    while (i--) {\n        this.instances[i].update(value)\n    }\n    this.pub()\n}\n\n/*\n *  -- computed property only --    \n *  Force all instances to re-evaluate themselves\n */\nBindingProto.refresh = function () {\n    var i = this.instances.length\n    while (i--) {\n        this.instances[i].refresh()\n    }\n}\n\n/*\n *  Unbind the binding, remove itself from all of its dependencies\n */\nBindingProto.unbind = function () {\n    var i = this.instances.length\n    while (i--) {\n        this.instances[i].unbind()\n    }\n    i = this.deps.length\n    var subs\n    while (i--) {\n        subs = this.deps[i].subs\n        subs.splice(subs.indexOf(this), 1)\n    }\n    // TODO if this is a root level binding\n    this.compiler = this.pubs = this.subs = this.instances = this.deps = null\n}\n\n/*\n *  Notify computed properties that depend on this binding\n *  to update themselves\n */\nBindingProto.pub = function () {\n    var i = this.subs.length\n    while (i--) {\n        this.subs[i].refresh()\n    }\n}\n\nmodule.exports = Binding//@ sourceURL=seed/src/binding.js"
));
require.register("seed/src/observe.js", Function("exports, require, module",
"var Emitter = require('emitter'),\n    utils   = require('./utils'),\n    typeOf  = utils.typeOf,\n    def     = Object.defineProperty,\n    slice   = Array.prototype.slice,\n    methods = ['push','pop','shift','unshift','splice','sort','reverse']\n\nvar arrayMutators = {\n    remove: function (index) {\n        if (typeof index !== 'number') index = this.indexOf(index)\n        this.splice(index, 1)\n    },\n    replace: function (index, data) {\n        if (typeof index !== 'number') index = this.indexOf(index)\n        this.splice(index, 1, data)\n    }\n}\n\nmethods.forEach(function (method) {\n    arrayMutators[method] = function () {\n        var result = Array.prototype[method].apply(this, arguments)\n\n        // watch new objects - do we need this? maybe do it in each.js\n\n        // var newElements\n        // if (method === 'push' || method === 'unshift') {\n        //     newElements = arguments\n        // } else if (method === 'splice') {\n        //     newElements = slice.call(arguments, 2)\n        // }\n        // if (newElements) {\n        //     var i = newElements.length\n        //     while (i--) watch(newElements[i])\n        // }\n        this.__observer__.emit('mutate', this.__path__, this, {\n            method: method,\n            args: slice.call(arguments),\n            result: result\n        })\n    }\n})\n\n// EXTERNAL\nfunction observe (obj, path, observer) {\n    if (isWatchable(obj)) {\n        path = path + '.'\n        var alreadyConverted = !!obj.__observer__\n        if (!alreadyConverted) {\n            var ob = new Emitter()\n            defProtected(obj, '__observer__', ob)\n        }\n        obj.__observer__\n            .on('get', function (key) {\n                observer.emit('get', path + key)\n            })\n            .on('set', function (key, val) {\n                observer.emit('set', path + key, val)\n            })\n            .on('mutate', function (key, val, mutation) {\n                observer.emit('mutate', path + key, val, mutation)\n            })\n        if (!alreadyConverted) {\n            watch(obj, null, ob)\n        }\n    }\n}\n\n// INTERNAL\nfunction watch (obj, path, observer) {\n    var type = typeOf(obj)\n    if (type === 'Object') {\n        watchObject(obj, path, observer)\n    } else if (type === 'Array') {\n        watchArray(obj, path, observer)\n    }\n}\n\nfunction watchObject (obj, path, observer) {\n    defProtected(obj, '__values__', {})\n    defProtected(obj, '__observer__', observer)\n    for (var key in obj) {\n        bind(obj, key, path, obj.__observer__)\n    }\n}\n\nfunction watchArray (arr, path, observer) {\n    defProtected(arr, '__path__', path)\n    defProtected(arr, '__observer__', observer)\n    for (var method in arrayMutators) {\n        defProtected(arr, method, arrayMutators[method])\n    }\n    // var i = arr.length\n    // while (i--) watch(arr[i])\n}\n\nfunction bind (obj, key, path, observer) {\n    var val = obj[key],\n        values = obj.__values__,\n        fullKey = (path ? path + '.' : '') + key\n    values[fullKey] = val\n    observer.emit('set', fullKey, val)\n    def(obj, key, {\n        enumerable: true,\n        get: function () {\n            observer.emit('get', fullKey)\n            return values[fullKey]\n        },\n        set: function (newVal) {\n            values[fullKey] = newVal\n            watch(newVal, fullKey, observer)\n            observer.emit('set', fullKey, newVal)\n        }\n    })\n    watch(val, fullKey, observer)\n}\n\nfunction defProtected (obj, key, val) {\n    def(obj, key, {\n        enumerable: false,\n        configurable: false,\n        value: val\n    })\n}\n\nfunction isWatchable (obj) {\n    var type = typeOf(obj)\n    return type === 'Object' || type === 'Array'\n}\n\nmodule.exports = observe//@ sourceURL=seed/src/observe.js"
));
require.register("seed/src/directive-parser.js", Function("exports, require, module",
"var config     = require('./config'),\n    utils      = require('./utils'),\n    directives = require('./directives'),\n    filters    = require('./filters')\n\nvar KEY_RE          = /^[^\\|<]+/,\n    ARG_RE          = /([^:]+):(.+)$/,\n    FILTERS_RE      = /\\|[^\\|<]+/g,\n    FILTER_TOKEN_RE = /[^\\s']+|'[^']+'/g,\n    INVERSE_RE      = /^!/,\n    NESTING_RE      = /^\\^+/,\n    ONEWAY_RE       = /-oneway$/\n\n/*\n *  Directive class\n *  represents a single directive instance in the DOM\n */\nfunction Directive (directiveName, expression, oneway) {\n\n    var prop,\n        definition = directives[directiveName]\n\n    // mix in properties from the directive definition\n    if (typeof definition === 'function') {\n        this._update = definition\n    } else {\n        this._update = definition.update\n        for (prop in definition) {\n            if (prop !== 'update') {\n                if (prop === 'unbind') {\n                    this._unbind = definition[prop]\n                } else {\n                    this[prop] = definition[prop]\n                }\n            }\n        }\n    }\n\n    this.oneway        = !!oneway\n    this.directiveName = directiveName\n    this.expression    = expression.trim()\n    this.rawKey        = expression.match(KEY_RE)[0].trim()\n    \n    this.parseKey(this.rawKey)\n    \n    var filterExps = expression.match(FILTERS_RE)\n    this.filters = filterExps\n        ? filterExps.map(parseFilter)\n        : null\n}\n\nvar DirProto = Directive.prototype\n\n/*\n *  called when a new value is set \n *  for computed properties, this will only be called once\n *  during initialization.\n */\nDirProto.update = function (value) {\n    if (value && (value === this.value)) return\n    this.value = value\n    this.apply(value)\n}\n\n/*\n *  -- computed property only --\n *  called when a dependency has changed\n */\nDirProto.refresh = function () {\n    // pass element and viewmodel info to the getter\n    // enables powerful context-aware bindings\n    var value = this.value.get({\n        el: this.el,\n        vm: this.vm\n    })\n    if (value === this.computedValue) return\n    this.computedValue = value\n    this.apply(value)\n    this.binding.pub()\n}\n\n/*\n *  Actually invoking the _update from the directive's definition\n */\nDirProto.apply = function (value) {\n    if (this.inverse) value = !value\n    this._update(\n        this.filters\n        ? this.applyFilters(value)\n        : value\n    )\n}\n\n/*\n *  pipe the value through filters\n */\nDirProto.applyFilters = function (value) {\n    var filtered = value, filter\n    for (var i = 0, l = this.filters.length; i < l; i++) {\n        filter = this.filters[i]\n        if (!filter.apply) throw new Error('Unknown filter: ' + filter.name)\n        filtered = filter.apply(filtered, filter.args)\n    }\n    return filtered\n}\n\n/*\n *  parse a key, extract argument and nesting/root info\n */\nDirProto.parseKey = function (rawKey) {\n\n    var argMatch = rawKey.match(ARG_RE)\n\n    var key = argMatch\n        ? argMatch[2].trim()\n        : rawKey.trim()\n\n    this.arg = argMatch\n        ? argMatch[1].trim()\n        : null\n\n    this.inverse = INVERSE_RE.test(key)\n    if (this.inverse) {\n        key = key.slice(1)\n    }\n\n    var nesting = key.match(NESTING_RE)\n    this.nesting = nesting\n        ? nesting[0].length\n        : false\n\n    this.root = key.charAt(0) === '$'\n\n    if (this.nesting) {\n        key = key.replace(NESTING_RE, '')\n    } else if (this.root) {\n        key = key.slice(1)\n    }\n\n    this.key = key\n}\n\n/*\n *  unbind noop, to be overwritten by definitions\n */\nDirProto.unbind = function (update) {\n    if (!this.el) return\n    if (this._unbind) this._unbind(update)\n    if (!update) this.vm = this.el = this.binding = this.compiler = null\n}\n\n/*\n *  parse a filter expression\n */\nfunction parseFilter (filter) {\n\n    var tokens = filter.slice(1)\n        .match(FILTER_TOKEN_RE)\n        .map(function (token) {\n            return token.replace(/'/g, '').trim()\n        })\n\n    return {\n        name  : tokens[0],\n        apply : filters[tokens[0]],\n        args  : tokens.length > 1\n                ? tokens.slice(1)\n                : null\n    }\n}\n\nmodule.exports = {\n\n    /*\n     *  make sure the directive and expression is valid\n     *  before we create an instance\n     */\n    parse: function (dirname, expression) {\n\n        var prefix = config.prefix\n        if (dirname.indexOf(prefix) === -1) return null\n        dirname = dirname.slice(prefix.length + 1)\n\n        var oneway = ONEWAY_RE.test(dirname)\n        if (oneway) {\n            dirname = dirname.slice(0, -7)\n        }\n\n        var dir   = directives[dirname],\n            valid = KEY_RE.test(expression)\n\n        if (!dir) utils.warn('unknown directive: ' + dirname)\n        if (!valid) utils.warn('invalid directive expression: ' + expression)\n\n        return dir && valid\n            ? new Directive(dirname, expression, oneway)\n            : null\n    }\n}//@ sourceURL=seed/src/directive-parser.js"
));
require.register("seed/src/text-parser.js", Function("exports, require, module",
"var config     = require('./config'),\n    ESCAPE_RE  = /[-.*+?^${}()|[\\]\\/\\\\]/g,\n    BINDING_RE\n\n/*\n *  Escapes a string so that it can be used to construct RegExp\n */\nfunction escapeRegex (val) {\n    return val.replace(ESCAPE_RE, '\\\\$&')\n}\n\nmodule.exports = {\n\n    /*\n     *  Parse a piece of text, return an array of tokens\n     */\n    parse: function (node) {\n        if (!BINDING_RE) module.exports.buildRegex()\n        var text = node.nodeValue\n        if (!BINDING_RE.test(text)) return null\n        var m, i, tokens = []\n        do {\n            m = text.match(BINDING_RE)\n            if (!m) break\n            i = m.index\n            if (i > 0) tokens.push(text.slice(0, i))\n            tokens.push({ key: m[1] })\n            text = text.slice(i + m[0].length)\n        } while (true)\n        if (text.length) tokens.push(text)\n        return tokens\n    },\n\n    /*\n     *  Build interpolate tag regex from config settings\n     */\n    buildRegex: function () {\n        var open = escapeRegex(config.interpolateTags.open),\n            close = escapeRegex(config.interpolateTags.close)\n        BINDING_RE = new RegExp(open + '(.+?)' + close)\n    }\n}//@ sourceURL=seed/src/text-parser.js"
));
require.register("seed/src/deps-parser.js", Function("exports, require, module",
"var Emitter  = require('emitter'),\n    config   = require('./config'),\n    utils    = require('./utils'),\n    observer = new Emitter()\n\nvar dummyEl = document.createElement('div'),\n    ARGS_RE = /^function\\s*?\\((.+?)[\\),]/,\n    SCOPE_RE_STR = '\\\\.vm\\\\.[\\\\.A-Za-z0-9_][\\\\.A-Za-z0-9_$]*',\n    noop = function () {}\n\n/*\n *  Auto-extract the dependencies of a computed property\n *  by recording the getters triggered when evaluating it.\n *\n *  However, the first pass will contain duplicate dependencies\n *  for computed properties. It is therefore necessary to do a\n *  second pass in injectDeps()\n */\nfunction catchDeps (binding) {\n    observer.on('get', function (dep) {\n        binding.deps.push(dep)\n    })\n    parseContextDependency(binding)\n    binding.value.get({\n        vm: createDummyVM(binding),\n        el: dummyEl\n    })\n    observer.off('get')\n}\n\n/*\n *  The second pass of dependency extraction.\n *  Only include dependencies that don't have dependencies themselves.\n */\nfunction filterDeps (binding) {\n    var i = binding.deps.length, dep\n    utils.log('\\n─ ' + binding.key)\n    while (i--) {\n        dep = binding.deps[i]\n        if (!dep.deps.length) {\n            utils.log('  └─ ' + dep.key)\n            dep.subs.push(binding)\n        } else {\n            binding.deps.splice(i, 1)\n        }\n    }\n    var ctxDeps = binding.contextDeps\n    if (!ctxDeps || !config.debug) return\n    i = ctxDeps.length\n    while (i--) {\n        utils.log('  └─ ctx:' + ctxDeps[i])\n    }\n}\n\n/*\n *  We need to invoke each binding's getter for dependency parsing,\n *  but we don't know what sub-viewmodel properties the user might try\n *  to access in that getter. To avoid thowing an error or forcing\n *  the user to guard against an undefined argument, we staticly\n *  analyze the function to extract any possible nested properties\n *  the user expects the target viewmodel to possess. They are all assigned\n *  a noop function so they can be invoked with no real harm.\n */\nfunction createDummyVM (binding) {\n    var viewmodel = {},\n        deps = binding.contextDeps\n    if (!deps) return viewmodel\n    var i = binding.contextDeps.length,\n        j, level, key, path\n    while (i--) {\n        level = viewmodel\n        path = deps[i].split('.')\n        j = 0\n        while (j < path.length) {\n            key = path[j]\n            if (!level[key]) level[key] = noop\n            level = level[key]\n            j++\n        }\n    }\n    return viewmodel\n}\n\n/*\n *  Extract context dependency paths\n */\nfunction parseContextDependency (binding) {\n    var fn   = binding.rawGet,\n        str  = fn.toString(),\n        args = str.match(ARGS_RE)\n    if (!args) return null\n    binding.isContextual = true\n    var depsRE = new RegExp(args[1] + SCOPE_RE_STR, 'g'),\n        matches = str.match(depsRE),\n        base = args[1].length + 4\n    if (!matches) return null\n    var i = matches.length,\n        deps = [], dep\n    while (i--) {\n        dep = matches[i].slice(base)\n        if (deps.indexOf(dep) === -1) {\n            deps.push(dep)\n        }\n    }\n    binding.contextDeps = deps\n    binding.compiler.contextBindings.push(binding)\n}\n\nmodule.exports = {\n\n    /*\n     *  the observer that catches events triggered by getters\n     */\n    observer: observer,\n\n    /*\n     *  parse a list of computed property bindings\n     */\n    parse: function (bindings) {\n        utils.log('\\nparsing dependencies...')\n        observer.isObserving = true\n        bindings.forEach(catchDeps)\n        bindings.forEach(filterDeps)\n        observer.isObserving = false\n        utils.log('\\ndone.')\n    }\n}//@ sourceURL=seed/src/deps-parser.js"
));
require.register("seed/src/filters.js", Function("exports, require, module",
"var keyCodes = {\n    enter    : 13,\n    tab      : 9,\n    'delete' : 46,\n    up       : 38,\n    left     : 37,\n    right    : 39,\n    down     : 40,\n    esc      : 27\n}\n\nmodule.exports = {\n\n    trim: function (value) {\n        return value ? value.toString().trim() : ''\n    },\n\n    capitalize: function (value) {\n        if (!value) return ''\n        value = value.toString()\n        return value.charAt(0).toUpperCase() + value.slice(1)\n    },\n\n    uppercase: function (value) {\n        return value ? value.toString().toUpperCase() : ''\n    },\n\n    lowercase: function (value) {\n        return value ? value.toString().toLowerCase() : ''\n    },\n\n    pluralize: function (value, args) {\n        return args.length > 1\n            ? (args[value - 1] || args[args.length - 1])\n            : (args[value - 1] || args[0] + 's')\n    },\n\n    currency: function (value, args) {\n        if (!value) return ''\n        var sign = (args && args[0]) || '$',\n            i = value % 3,\n            f = '.' + value.toFixed(2).slice(-2),\n            s = Math.floor(value).toString()\n        return sign + s.slice(0, i) + s.slice(i).replace(/(\\d{3})(?=\\d)/g, '$1,') + f\n    },\n\n    key: function (handler, args) {\n        if (!handler) return\n        var code = keyCodes[args[0]]\n        if (!code) {\n            code = parseInt(args[0], 10)\n        }\n        return function (e) {\n            if (e.keyCode === code) {\n                handler.call(this, e)\n            }\n        }\n    }\n\n}//@ sourceURL=seed/src/filters.js"
));
require.register("seed/src/directives/index.js", Function("exports, require, module",
"module.exports = {\n\n    on    : require('./on'),\n    each  : require('./each'),\n\n    attr: function (value) {\n        this.el.setAttribute(this.arg, value)\n    },\n\n    text: function (value) {\n        this.el.textContent =\n            (typeof value === 'string' || typeof value === 'number')\n            ? value : ''\n    },\n\n    html: function (value) {\n        this.el.innerHTML =\n            (typeof value === 'string' || typeof value === 'number')\n            ? value : ''\n    },\n\n    show: function (value) {\n        this.el.style.display = value ? '' : 'none'\n    },\n\n    visible: function (value) {\n        this.el.style.visibility = value ? '' : 'hidden'\n    },\n    \n    focus: function (value) {\n        var el = this.el\n        setTimeout(function () {\n            el[value ? 'focus' : 'focus']()\n        }, 0)\n    },\n\n    class: function (value) {\n        if (this.arg) {\n            this.el.classList[value ? 'add' : 'remove'](this.arg)\n        } else {\n            if (this.lastVal) {\n                this.el.classList.remove(this.lastVal)\n            }\n            this.el.classList.add(value)\n            this.lastVal = value\n        }\n    },\n\n    value: {\n        bind: function () {\n            if (this.oneway) return\n            var el = this.el, self = this\n            this.change = function () {\n                self.vm[self.key] = el.value\n            }\n            el.addEventListener('keyup', this.change)\n        },\n        update: function (value) {\n            this.el.value = value ? value : ''\n        },\n        unbind: function () {\n            if (this.oneway) return\n            this.el.removeEventListener('keyup', this.change)\n        }\n    },\n\n    checked: {\n        bind: function () {\n            if (this.oneway) return\n            var el = this.el, self = this\n            this.change = function () {\n                self.vm[self.key] = el.checked\n            }\n            el.addEventListener('change', this.change)\n        },\n        update: function (value) {\n            this.el.checked = !!value\n        },\n        unbind: function () {\n            if (this.oneway) return\n            this.el.removeEventListener('change', this.change)\n        }\n    },\n\n    'if': {\n        bind: function () {\n            this.parent = this.el.parentNode\n            this.ref = document.createComment('sd-if-' + this.key)\n            var next = this.el.nextSibling\n            if (next) {\n                this.parent.insertBefore(this.ref, next)\n            } else {\n                this.parent.appendChild(this.ref)\n            }\n        },\n        update: function (value) {\n            if (!value) {\n                if (this.el.parentNode) {\n                    this.parent.removeChild(this.el)\n                }\n            } else {\n                if (!this.el.parentNode) {\n                    this.parent.insertBefore(this.el, this.ref)\n                }\n            }\n        }\n    },\n\n    style: {\n        bind: function () {\n            this.arg = convertCSSProperty(this.arg)\n        },\n        update: function (value) {\n            this.el.style[this.arg] = value\n        }\n    }\n}\n\n/*\n *  convert hyphen style CSS property to Camel style\n */\nvar CONVERT_RE = /-(.)/g\nfunction convertCSSProperty (prop) {\n    if (prop.charAt(0) === '-') prop = prop.slice(1)\n    return prop.replace(CONVERT_RE, function (m, char) {\n        return char.toUpperCase()\n    })\n}//@ sourceURL=seed/src/directives/index.js"
));
require.register("seed/src/directives/each.js", Function("exports, require, module",
"var config = require('../config'),\n    utils  = require('../utils'),\n    ViewModel // lazy def to avoid circular dependency\n\n/*\n *  Mathods that perform precise DOM manipulation\n *  based on mutator method triggered\n */\nvar mutationHandlers = {\n\n    push: function (m) {\n        var i, l = m.args.length,\n            baseIndex = this.collection.length - l\n        for (i = 0; i < l; i++) {\n            this.buildItem(this.ref, m.args[i], baseIndex + i)\n        }\n    },\n\n    pop: function (m) {\n        m.result.$destroy()\n    },\n\n    unshift: function (m) {\n        var i, l = m.args.length, ref\n        for (i = 0; i < l; i++) {\n            ref = this.collection.length > l\n                ? this.collection[l].$el\n                : this.ref\n            this.buildItem(ref, m.args[i], i)\n        }\n        this.updateIndexes()\n    },\n\n    shift: function (m) {\n        m.result.$destroy()\n        this.updateIndexes()\n    },\n\n    splice: function (m) {\n        var i, pos, ref,\n            l = m.args.length,\n            k = m.result.length,\n            index   = m.args[0],\n            removed = m.args[1],\n            added   = l - 2\n        for (i = 0; i < k; i++) {\n            m.result[i].$destroy()\n        }\n        if (added > 0) {\n            for (i = 2; i < l; i++) {\n                pos  = index - removed + added + 1\n                ref  = this.collection[pos]\n                     ? this.collection[pos].$el\n                     : this.ref\n                this.buildItem(ref, m.args[i], index + i)\n            }\n        }\n        if (removed !== added) {\n            this.updateIndexes()\n        }\n    },\n\n    sort: function () {\n        var i, l = this.collection.length, viewmodel\n        for (i = 0; i < l; i++) {\n            viewmodel = this.collection[i]\n            viewmodel.$index = i\n            this.container.insertBefore(viewmodel.$el, this.ref)\n        }\n    }\n}\n\n//mutationHandlers.reverse = mutationHandlers.sort\n\nmodule.exports = {\n\n    bind: function () {\n        this.el.removeAttribute(config.prefix + '-each')\n        var ctn = this.container = this.el.parentNode\n        // create a comment node as a reference node for DOM insertions\n        this.ref = document.createComment('sd-each-' + this.arg)\n        ctn.insertBefore(this.ref, this.el)\n        ctn.removeChild(this.el)\n    },\n\n    update: function (collection) {\n\n        this.unbind(true)\n        // attach an object to container to hold handlers\n        this.container.sd_dHandlers = {}\n        // if initiating with an empty collection, we need to\n        // force a compile so that we get all the bindings for\n        // dependency extraction.\n        if (!this.collection && !collection.length) {\n            this.buildItem(this.ref, null, null)\n        }\n        this.collection = collection\n\n        // listen for collection mutation events\n        // the collection has been augmented during Binding.set()\n        collection.__observer__.on('mutate', (function (mutation) {\n            mutationHandlers[mutation.method].call(this, mutation)\n        }).bind(this))\n\n        // create child-seeds and append to DOM\n        for (var i = 0, l = collection.length; i < l; i++) {\n            this.buildItem(this.ref, collection[i], i)\n        }\n    },\n\n    buildItem: function (ref, data, index) {\n        var node = this.el.cloneNode(true)\n        this.container.insertBefore(node, ref)\n        ViewModel = ViewModel || require('../viewmodel')\n        var vmID = node.getAttribute(config.prefix + '-viewmodel'),\n            ChildVM = utils.getVM(vmID) || ViewModel\n        var item = new ChildVM({\n            el: node,\n            each: true,\n            eachPrefix: this.arg + '.',\n            parentCompiler: this.compiler,\n            index: index,\n            data: data,\n            delegator: this.container\n        })\n        if (index !== null) {\n            this.collection[index] = item\n        } else {\n            item.$destroy()\n        }\n    },\n\n    updateIndexes: function () {\n        var i = this.collection.length\n        while (i--) {\n            this.collection[i].$index = i\n        }\n    },\n\n    unbind: function () {\n        if (this.collection) {\n            this.collection.off('mutate')\n            var i = this.collection.length\n            while (i--) {\n                this.collection[i].$destroy()\n            }\n        }\n        var ctn = this.container,\n            handlers = ctn.sd_dHandlers\n        for (var key in handlers) {\n            ctn.removeEventListener(handlers[key].event, handlers[key])\n        }\n        ctn.sd_dHandlers = null\n    }\n}//@ sourceURL=seed/src/directives/each.js"
));
require.register("seed/src/directives/on.js", Function("exports, require, module",
"function delegateCheck (current, top, identifier) {\n    if (current[identifier]) {\n        return current\n    } else if (current === top) {\n        return false\n    } else {\n        return delegateCheck(current.parentNode, top, identifier)\n    }\n}\n\nmodule.exports = {\n\n    expectFunction : true,\n\n    bind: function () {\n        if (this.compiler.each) {\n            // attach an identifier to the el\n            // so it can be matched during event delegation\n            this.el[this.expression] = true\n            // attach the owner viewmodel of this directive\n            this.el.sd_viewmodel = this.vm\n        }\n    },\n\n    update: function (handler) {\n\n        this.unbind(true)\n        if (!handler) return\n\n        var compiler = this.compiler,\n            event    = this.arg,\n            ownerVM  = this.binding.compiler.vm\n\n        if (compiler.each && event !== 'blur' && event !== 'blur') {\n\n            // for each blocks, delegate for better performance\n            // focus and blur events dont bubble so exclude them\n            var delegator  = compiler.delegator,\n                identifier = this.expression,\n                dHandler   = delegator.sd_dHandlers[identifier]\n\n            if (dHandler) return\n\n            // the following only gets run once for the entire each block\n            dHandler = delegator.sd_dHandlers[identifier] = function (e) {\n                var target = delegateCheck(e.target, delegator, identifier)\n                if (target) {\n                    e.el = target\n                    e.vm = target.sd_viewmodel\n                    handler.call(ownerVM, e)\n                }\n            }\n            dHandler.event = event\n            delegator.addEventListener(event, dHandler)\n\n        } else {\n\n            // a normal, single element handler\n            var vm = this.vm\n            this.handler = function (e) {\n                e.el = e.currentTarget\n                e.vm = vm\n                handler.call(vm, e)\n            }\n            this.el.addEventListener(event, this.handler)\n\n        }\n    },\n\n    unbind: function (update) {\n        this.el.removeEventListener(this.arg, this.handler)\n        this.handler = null\n        if (!update) this.el.sd_viewmodel = null\n    }\n}//@ sourceURL=seed/src/directives/on.js"
));
require.alias("component-emitter/index.js", "seed/deps/emitter/index.js");
require.alias("component-emitter/index.js", "emitter/index.js");
require.alias("component-indexof/index.js", "component-emitter/deps/indexof/index.js");

require.alias("seed/src/main.js", "seed/index.js");

window.Seed = window.Seed || require('seed')
Seed.version = 'dev'
})();